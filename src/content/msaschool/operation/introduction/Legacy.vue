<template>
    <div>
        <mark-down class="content">
            

## AI를 활용한 코드 평가 및 분석

- 먼저, 환경을 구축하기 위해 https://github.com/msa-school/food-delivery-app-gen 에 접속하여 Github Repository fork를 진행합니다.

- 이후, fork한 Repository를 PC에 내려받은 후 Cursor IDE에서 프로젝트를 실행합니다.

- Ctrl + L > '@'입력 > 'Folders'클릭 > 'order-management'클릭을 진행하여 폴더 내부의 파일 전체에 관한 질문을 보낼 수 있습니다.

- 이후, 폴더 내부에 위치한 파일들의 이해를 목적으로 하는 프롬프트 '이 폴더가 전체적으로 뭘 하는지 설명해줘'를 입력하면 다음과 같은 결과값을 확인할 수 있습니다.
![](https://github.com/msa-ez/llmschool.github.io/assets/123912988/a724441c-2a98-4ba3-a129-d130798ca09a)

다음은 폴더를 멘션한 상태에서 코드 품질을 평가하는 예제입니다.

- 이전에 진행한 OPEN AI영역에서 다음과 같이 프롬프트를 입력합니다.
```
어떤 아키텍쳐 스타일? 1.트랜잭션 스크립트 2. 액티브 오브젝트 3. 도메인 클래스
```
- 프롬프트의 결과값으로 해당 폴더에 아래와 같이 트랙잭션 스크립트 아키텍쳐 스타일을 사용하는 것을 확인할 수 있습니다.
![](https://github.com/msa-ez/llmschool.github.io/assets/123912988/d4a74593-8731-4df4-bed5-61ec57f9a9ab)

AI를 통해 해당 폴더의 구조를 분석할 수도 있습니다.

먼저 클래스다이어그램을 통해 정적분석을 진행하는 방법입니다.

- 이전에 진행한 OPEN AI영역에서 다음과 같이 프롬프트를 입력합니다.
```
이 모듈의 구조를 클래스다이어그램으로 설명해줘
```
- 프롬프트의 결과값으로 아래와 같이 클래스 다이어그램으로 생성된 것을 확인할 수 있습니다.
![](https://github.com/msa-ez/llmschool.github.io/assets/123912988/f7f85504-2e84-4ded-ac84-da7d8802f017)

다음은 시퀀스다이어그램을 통해 동적분석을 진행하는 방법입니다.

- 이전에 진행한 OPEN AI영역에서 다음과 같이 프롬프트를 입력합니다.
```
이 모듈의 동작구조를 시퀀스다이어그램으로 설명해줘
```
- 프롬프트의 결과값으로 아래와 같이 시퀀스 다이어그램이 생성된 것을 확인할 수 있습니다.
![](https://github.com/msa-ez/llmschool.github.io/assets/123912988/708af8e7-6984-4eab-ba4d-1e891ba911da)

만약 결과값으로 다이어그램이 정상 생성되지 않는다면, 다음과 같이 프롬프트를 추가로 입력하여 나온 결과값을 복사하여 https://sequencediagram.org/ 에 paste를 진행하면 생성된 결과값을 확인할 수 있습니다.

```
sequencediagram.org 문법으로 작성해줘
```

### AI를 활용한 코드 전환

AI를 활용한다면 설계 패턴에 따라 코드를 변경하거나 다른 마이크로서비스의 코드를 참조하여 코드 스타일을 변경할 수 있습니다.

먼저 설계 패턴에 따라 코드를 변경하는 방법입니다.

- OPEN AI영역에 폴더 멘션을 진행한 상태에서 다음과 같이 프롬프트를 입력합니다.
```
해당 어플리케이션을 Clean Architecture와 JPA를 사용하는 방식으로 전환해줘
```
OPEN AI는 폴더에 정의된 코드들을 분석하여 요구사항과 비교하고 각 파일에 변경되어야하는 내용을 단계적으로 안내하는 결과값을 반환합니다. 이후 전환된 코드의 예시를 이어서 설명하며 아래와 같이 생성되는 것을 확인할 수 있습니다.
![](https://github.com/msa-ez/llmschool.github.io/assets/123912988/67fc71a1-7854-4bf7-bbeb-eb3f25e262bd)

다음은 JSP기반으로 구성된 파일을 분리하여 요구사항에 맞게 코드를 전환하는 예제입니다.
JSP란 Java를 이용한 서버 사이드 템플릿 엔진이며, 자바를 웹서버에서 사용하기 위한 도구를 의미합니다.

- 먼저, 'createPayment.jsp'파일을 띄운 후 Ctrl + L OPEN AI를 실행합니다.

- 이후 다음과 같이 프롬프트를 입력합니다.
```
이 jsp파일을 클린아키텍쳐로 전환하려고해. 프론트엔드는 react.js로 백엔드는 spring-boot로 전환할거고 이해했다면 ok라고만 답해줘.
```
프롬프트에 대한 결과값을 바로 반환하지 않는 이유는 예상되는 결과값 즉, context가 클 경우 OPEN AI가 가지고 있는 토큰수의 범위내에서 답변하려는 성질로 인해 좋은 결과값을 기대하기 어렵습니다.
따라서 사전에 파일과 요구사항에 대한 정보를 제공하고 이후 전체 요구사항을 분리하여 더욱 좋은 결과값을 반환시키도록 해야합니다. 

- 먼저 백엔드에 대한 코드를 생성하기 위해 다음과 같이 프롬프트를 입력합니다.
```
백엔드부터 클린아키텍쳐로 전환해줘
```
이렇게 하면 OPEN AI는 사전에 제공받은 정보중 백엔드에 관한 정보를 토대로 클린아키텍쳐로 전환한 코드를 제공하게됩니다.

- 이후 프론트엔드에 대한 코드를 생성하기 위해 다음과 같이 프롬프트를 입력합니다.
```
프론트엔트도 전환해줘
```
백엔드와 마찬가지로 OPEN AI가 가전에 제공받은 정보중 프론트엔드에 관한 요구사항을 토대로 전환한 코드를 제공하는 것을 확인할 수 있습니다.
        </mark-down>

    </div>
</template>


<script>
    // @group 01_01_04
    export default {
        name:'Legacy',
        data() {
            return {}
        },
        props: {
            "Cursor IDE - 레거시&전환": {
                type: String
            },
        },
    }
</script>
